{"version":3,"sources":["components/mainContainer/mainContainerStyle.module.css","components/stationTable/stationTable.module.css","util/data/fetchUtil.js","components/stationTable/useStationData.js","components/stationTable/statusMessage.js","components/stationTable/StationTable.js","components/mainContainer/MainContainer.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","fetchData","url","a","fetch","response","status","json","Error","useStationData","useState","stations","setStations","setStatus","updateStations","statuses","mappedStations","map","name","capacity","station_id","find","num_docks_available","num_bikes_available","useEffect","config","oslobysykkel","host","endpoints","stationInformation","stationStatus","data","fetchStationData","then","console","debug","catch","statusMessage","statusMessages","texts","stationTable","loading","error","dataCollected","StationTable","className","styles","tableContainer","columns","title","field","availableLocks","type","availableBikes","localization","body","emptyDataSourceMessage","isLoading","MainContainer","container","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"mHACAA,EAAOC,QAAU,CAAC,UAAY,wC,oBCA9BD,EAAOC,QAAU,CAAC,eAAiB,uC,gfCWpBC,EAZA,uCAAG,WAAMC,GAAN,eAAAC,EAAA,+EAEaC,MAAMF,GAFnB,UAIc,OAFlBG,EAFI,QAIGC,OAJH,yCAKC,SALD,uBAMGD,EAASE,OANZ,0EAQV,IAAIC,MAAJ,qCAAwCN,IAR9B,0DAAH,sDCoDAO,EAhDQ,WAAO,IAAD,EACOC,mBAAS,IADhB,mBAClBC,EADkB,KACRC,EADQ,OAEGF,mBAAS,WAFZ,mBAElBJ,EAFkB,KAEVO,EAFU,KAGnBC,EAAiB,SAACH,EAAUI,GAC9B,IAAMC,EAAiBL,EAASM,KAAI,YAAmC,IAAjCC,EAAgC,EAAhCA,KAAMC,EAA0B,EAA1BA,SAAUC,EAAgB,EAAhBA,WAAgB,EAI9DL,EAASM,MAAK,SAAAf,GAAM,OAAIc,IAAed,EAAOc,cAClD,MAAO,CACHF,OACAC,WACAG,oBAR8D,EAE9DA,oBAOAC,oBAT8D,EAG9DA,wBASRX,EAAYI,GACZH,EAAU,mBA4Bd,OAzBAW,qBAAU,WAAO,IAAD,EAORC,EAAOC,aALPC,EAFQ,EAERA,KAFQ,IAGRC,UACIC,EAJI,EAIJA,mBACAC,EALI,EAKJA,eAIc,uCAAG,8BAAA3B,EAAA,sEACEF,EAAU0B,EAAOE,GADnB,cACflB,EADe,gBAEAV,EAAU0B,EAAOG,GAFjB,OAEfxB,EAFe,OAIJ,UAAbK,GAAmC,UAAXL,EACxBO,EAAU,SAEVC,EAAeH,EAASoB,KAAKpB,SAAUL,EAAOyB,KAAKpB,UAPlC,2CAAH,qDAUtBqB,GACKC,MAAK,kBAAMC,QAAQC,MAAM,qBACzBC,OAAM,kBAAMvB,EAAU,cAE5B,IAEI,CAACF,WAAUL,W,kBCjCP+B,EAdO,SAAA/B,GAClB,IAAMgC,EAAiBC,EAAMC,aAAalC,OAC1C,OAAQA,GACJ,IAAK,UACD,OAAOgC,EAAeG,QAC1B,IAAK,QACD,OAAOH,EAAeI,MAC1B,IAAK,iBACD,OAAOJ,EAAeK,cAC1B,QACI,MAAO,KCoBJC,EAzBM,WAAM,MAGInC,IAApBE,EAHgB,EAGhBA,SAAUL,EAHM,EAGNA,OACjB,OACI,yBAAKuC,UAAWC,IAAOC,gBACnB,kBAAC,IAAD,CACIC,QAAS,CACL,CAACC,MAAOV,EAAMC,aAAatB,KAAMgC,MAAO,QACxC,CAACD,MAAOV,EAAMC,aAAaW,eAAgBD,MAAO,sBAAuBE,KAAM,WAC/E,CAACH,MAAOV,EAAMC,aAAaa,eAAgBH,MAAO,sBAAuBE,KAAM,YAEnFE,aAAc,CACVC,KAAM,CACFC,uBAAwBnB,EAAc/B,KAG9CyB,KAAMpB,EACN8C,UAAsB,YAAXnD,EACX2C,MAAOV,EAAMC,aAAaS,UCb3BS,EATO,WAClB,OAAO,8BACH,yBAAKb,UAAWC,IAAOa,WACnB,kBAAC,EAAD,SCIGC,MARf,WACE,OACE,6BACC,kBAAC,EAAD,QCMeC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBvC,MAAK,SAAAwC,GACJA,EAAaC,gBAEdtC,OAAM,SAAAM,GACLR,QAAQQ,MAAMA,EAAMiC,a","file":"static/js/main.58239407.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"mainContainerStyle_container__1lxRa\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tableContainer\":\"stationTable_tableContainer__24RL6\"};","const fetchData = async url => {\r\n    try {\r\n        const response = await fetch(url);\r\n\r\n        if (response.status !== 200)\r\n            return 'error';\r\n        return await response.json();\r\n    } catch (e) {\r\n        new Error(`Failed to fetch data from: ${url}`);\r\n    }\r\n};\r\n\r\nexport default fetchData;","import {useEffect, useState} from 'react';\r\nimport config from '../../config.json';\r\nimport fetchData from '../../util/data/fetchUtil';\r\n\r\nconst useStationData = () => {\r\n    const [stations, setStations] = useState([]);\r\n    const [status, setStatus] = useState('LOADING');\r\n    const updateStations = (stations, statuses) => {\r\n        const mappedStations = stations.map(({name, capacity, station_id}) => {\r\n            const {\r\n                num_docks_available,\r\n                num_bikes_available\r\n            } = statuses.find(status => station_id === status.station_id);\r\n            return {\r\n                name,\r\n                capacity,\r\n                num_docks_available,\r\n                num_bikes_available\r\n            };\r\n        });\r\n        setStations(mappedStations);\r\n        setStatus('DATA_COLLECTED');\r\n    };\r\n\r\n    useEffect(() => {\r\n        const {\r\n            host,\r\n            endpoints: {\r\n                stationInformation,\r\n                stationStatus\r\n            }\r\n        } = config.oslobysykkel;\r\n\r\n        const fetchStationData = async () => {\r\n            const stations = await fetchData(host + stationInformation);\r\n            const status = await fetchData(host + stationStatus);\r\n\r\n            if (stations === 'error' || status === 'error')\r\n                setStatus('ERROR');\r\n            else\r\n                updateStations(stations.data.stations, status.data.stations);\r\n        };\r\n\r\n        fetchStationData()\r\n            .then(() => console.debug('retrieved data'))\r\n            .catch(() => setStatus('ERROR'));\r\n\r\n    }, []);\r\n\r\n    return {stations, status};\r\n};\r\n\r\nexport default useStationData;\r\n","import texts from '../../texts/texts_no';\r\n\r\nconst statusMessage = status => {\r\n    const statusMessages = texts.stationTable.status;\r\n    switch (status) {\r\n        case 'LOADING' :\r\n            return statusMessages.loading;\r\n        case 'ERROR':\r\n            return statusMessages.error;\r\n        case 'DATA_COLLECTED':\r\n            return statusMessages.dataCollected;\r\n        default:\r\n            return '';\r\n    }\r\n};\r\n\r\nexport default statusMessage;","import React from 'react';\r\nimport texts from '../../texts/texts_no';\r\nimport styles from './stationTable.module.css'\r\nimport useStationData from './useStationData';\r\nimport MaterialTable from 'material-table';\r\nimport statusMessage from './statusMessage';\r\n\r\nconst StationTable = () => {\r\n    // const StationInformationResponse = await fetch('http://www.mocky.io/v2/5e6397983600007500e8dd4a');\r\n\r\n    const {stations, status} = useStationData();\r\n    return (\r\n        <div className={styles.tableContainer}>\r\n            <MaterialTable\r\n                columns={[\r\n                    {title: texts.stationTable.name, field: 'name'},\r\n                    {title: texts.stationTable.availableLocks, field: 'num_docks_available', type: 'numeric'},\r\n                    {title: texts.stationTable.availableBikes, field: 'num_bikes_available', type: 'numeric'}\r\n                ]}\r\n                localization={{\r\n                    body: {\r\n                        emptyDataSourceMessage: statusMessage(status)\r\n                    }\r\n                }}\r\n                data={stations}\r\n                isLoading={status === 'LOADING'}\r\n                title={texts.stationTable.title}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default StationTable;\r\n","import React from 'react';\r\nimport styles from './mainContainerStyle.module.css'\r\nimport StationTable from '../stationTable/StationTable';\r\n\r\nconst MainContainer = () => {\r\n    return <main>\r\n        <div className={styles.container}>\r\n            <StationTable/>\r\n        </div>\r\n    </main>;\r\n};\r\n\r\n\r\nexport default MainContainer;","import React from 'react';\nimport MainContainer from './components/mainContainer/MainContainer';\n\nfunction App() {\n  return (\n    <div>\n     <MainContainer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}